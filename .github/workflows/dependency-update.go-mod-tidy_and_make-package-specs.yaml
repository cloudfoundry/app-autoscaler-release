name: "renovate-/ospo-bot: go mod tidy and make package-specs"
on:
  pull_request:
    branches:
      - "renovate/**"
      - "dependabot/**"
    paths:
      - ".github/workflows/dependency-update.go-mod-tidy_and_make-package-specs.yaml"
      - "src/**/go.mod"
      - "src/**/go.sum"
  push:
    # TODO: As soon as Github solves issue <https://github.com/actions/runner/issues/1182>
    # and this event-configuration remains identical to the one for `pull_request`,
    # anchors and aliases may be used, see the official
    # [yaml-documentation](<https://yaml.org/spec/1.2.2/#alias-nodes>).
    branches:
      - "renovate/**"
      - "dependabot/**"
    paths:
      - ".github/workflows/dependency-update.go-mod-tidy_and_make-package-specs.yaml"
      - "src/**/go.mod"
      - "src/**/go.sum"
  workflow_dispatch: {}
jobs:
  pkgs-specs_and_go-mod-tidy:
    name: "go mod tidy && make package-specs"
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
    steps:
      # We potentially want to add at the end a commit by the author of the most recent
      # commit in this branch. However github has some protection which prevents workflows
      # to run in case a commit has been pushed with the default job-specific github-token.
      # For this case we need to use another one here.
      #
      # For more information, see:
      # <https://docs.github.com/en/actions/security-guides/automatic-token-authentication#using-the-github_token-in-a-workflow>
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true
          token: ${{ secrets.APP_AUTOSCALER_CI_TOKEN }} # With push token that can trigger new PR jobs
      - name: Configure git
        shell: bash
        run: |
          #! /usr/bin/env bash
          set -eu -o pipefail

          declare -r commit_author_name="${{github.event.head_commit.author.name}}"
          declare -r commit_author_email="${{github.event.head_commit.author.email}}"

          git config --global --add safe.directory "${GITHUB_WORKSPACE}"
          git config user.name "${commit_author_name}"
          git config user.email "${commit_author_email}"
      - name: go-mod-tidy and make package-specs
        shell: bash
        run: |
          #! /usr/bin/env bash
          set -eu -o pipefail

          # We need the subsequent standard-message to determine if the last commit
          # has already cleaned up everything. In this case this workflow should not
          # change anything and we exit early.
          # An alternative would be to use a tag for this. But this does affect the whole
          # PR instead of just the latest commit.
          declare -r tidy_message='ü§ñü¶æüõ†Ô∏è go mod tidy & make package-specs'

          declare -r commit_author_name="${{github.event.head_commit.author.name}}"
          declare -r commit_message="${{github.event.head_commit.message}}"

          if [[ ! "${commit_author_name}" =~ ('dependabot'|'renovate')'[bot]' ]] \
             || [[ "${commit_message}" == "${tidy_message}" ]]
          then
            echo 'This commit was not by a known bot or already an automatic `go mod tidy`! Exiting ‚Ä¶'
            exit 0
          fi

          # Generated files are needed for `go mod tidy` which is a dependency of the
          # target `package-specs`. However the generation of them itself already
          # requires go-modules to be tidied up. So we need to generate the files
          # before changing `go.mod` and `go.sum`.
          declare -r current_branch="$(git branch --show-current)"
          git checkout 'HEAD~1'
          make generate-fakes
          make generate-openapi-generated-clients-and-servers
          git checkout "${current_branch}"

          # ‚ö†Ô∏è For this workflow to be successful, the subsequent line must not
          # trigger again the creation of the generated files.
          make package-specs

          declare -i -r num_changed_files="$(git status --porcelain | wc --lines)"
          if ((num_changed_files > 0))
          then
            echo 'Changes to some files were necessary!'
            git add .
            git commit --message="${tidy_message}"
            git push
          else
            echo 'No files changed!'
          fi
          echo 'üèÅ'
